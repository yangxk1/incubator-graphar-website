"use strict";(self.webpackChunkapache_website_template=self.webpackChunkapache_website_template||[]).push([[6005],{6194:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=r(1527),a=r(395);const o={},i="Co-Work with BGL",s={id:"libraries/cpp/examples/bgl",title:"Co-Work with BGL",description:"The [Boost Graph Library",source:"@site/docs/libraries/cpp/examples/bgl.md",sourceDirName:"libraries/cpp/examples",slug:"/libraries/cpp/examples/bgl",permalink:"/docs/libraries/cpp/examples/bgl",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/incubator-graphar/edit/main/docs/libraries/cpp/examples/bgl.md",tags:[],version:"current",frontMatter:{},sidebar:"documentation",previous:{title:"Examples",permalink:"/docs/category/examples"},next:{title:"Integrate into GraphScope",permalink:"/docs/libraries/cpp/examples/graphscope"}},p={},c=[];function d(e){const t={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"co-work-with-bgl",children:"Co-Work with BGL"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://cs.brown.edu/~jwicks/boost/libs/graph/doc/",children:"Boost Graph Library\n(BGL)"})," is the first\nC++ library to apply the principles of generic programming to the\nconstruction of the advanced data structures and algorithms used in\ngraph computations. The BGL graph interface and graph components are\ngeneric in the same sense as the Standard Template Library (STL). And it\nprovides some built-in algorithms which cover a core set of algorithm\npatterns and a larger set of graph algorithms."]}),"\n",(0,n.jsxs)(t.p,{children:["We take calculating CC as an example, to demonstrate how BGL works with\nGraphAr. A weakly connected component is a maximal subgraph of a graph\nsuch that for every pair of vertices in it, there is an undirected path\nconnecting them. And the CC algorithm is to identify all such components\nin a graph. Learn more about ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Connected_component",children:"the CC\nalgorithm"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The source code of CC based on BGL can be found at\n",(0,n.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/bgl_example.cc",children:"bgl_example.cc"}),".\nIn this program, the graph information file is first read to get the\nmetadata:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"std::string path = ... // the path of the graph information file\nauto graph_info = graphar::GraphInfo::Load(path).value();\n"})}),"\n",(0,n.jsx)(t.p,{children:"And then, the vertex collection and the edge collection are established\nas the handles to access the graph data:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'auto maybe_vertices = graphar::VerticesCollection::Make(graph_info, "person");\nauto vertices = maybe_vertices.value();\nauto maybe_edges = graphar::EdgesCollection::Make(graph_info, "person", "knows", "person", graphar::AdjListType::ordered_by_source);\nauto edges = maybe_edges.value();\n'})}),"\n",(0,n.jsx)(t.p,{children:"Next, we construct the in-memory graph data structure for BGL by\ntraversing the vertices and edges via GraphAr's high-level reading\ninterface (the vertex iterator and the edge iterator):"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'// define the Graph type in BGL\ntypedef boost::adjacency_list<boost::vecS, // use vector to store edges\n                              boost::vecS, // use vector to store vertices\n                              boost::undirectedS, // undirected\n                              boost::property<boost::vertex_name_t, int64_t>, // vertex property\n                              boost::no_property> Graph; // no edge property\n// descriptors for vertex in BGL\ntypedef typename boost::graph_traits<Graph>::vertex_descriptor Vertex;\n\n// declare a graph object with (num_vertices) vertices and an edge iterator\nstd::vector<std::pair<graphar::IdType, graphar::IdType>> edges_array;\nauto it_begin = edges->begin(), it_end = edges->end();\nfor (auto it = it_begin; it != it_end; ++it)\n   edges_array.push_back(std::make_pair(it.source(), it.destination()));\nGraph g(edges_array.begin(), edges_array.end(), num_vertices);\n\n// define the internal vertex property "id"\nboost::property_map<Graph, boost::vertex_name_t>::type id = get(boost::vertex_name_t(), g);\nauto v_it_begin = vertices->begin(), v_it_end = vertices->end();\nfor (auto it = v_it_begin; it != v_it_end; ++it) {\n   auto vertex = *it;\n   boost::put(id, vertex.id(), vertex.property<int64_t>("id").value());\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"After that, an internal CC algorithm provided by BGL is called:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'// define the external vertex property "component"\nstd::vector<int> component(num_vertices);\n// call algorithm: cc\nint cc_num = boost::connected_components(g, &component[0]);\nstd::cout << "Total number of components: " << cc_num << std::endl;\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Finally, we could use a ",(0,n.jsx)(t.strong,{children:"VerticesBuilder"})," of GraphAr to write the\nresults to new generated GraphAr format data:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'// construct a new property group\ngraphar::Property cc = {"cc", graphar::int32(), false};\nstd::vector<graphar::Property> property_vector = {cc};\nauto group = graphar::CreatePropertyGroup(property_vector, graphar::FileType::PARQUET);\n\n// construct the new vertex info\nstd::string vertex_type = "cc_result", vertex_prefix = "result/";\nint chunk_size = 100;\nauto new_info = graphar::CreateVertexInfo(vertex_type, chunk_size, {group}, vertex_prefix);\n\n// access the vertices via the index map and vertex iterator of BGL\ntypedef boost::property_map<Graph, boost::vertex_index_t>::type IndexMap;\nIndexMap index = boost::get(boost::vertex_index, g);\ntypedef boost::graph_traits<Graph>::vertex_iterator vertex_iter;\nstd::pair<vertex_iter, vertex_iter> vp;\n\n// dump the results through the VerticesBuilder\ngraphar::builder::VerticesBuilder builder(new_info, "/tmp/");\nfor (vp = boost::vertices(g); vp.first!= vp.second; ++vp.first) {\n   Vertex v = *vp.first;\n   graphar::builder::Vertex vertex(index[v]);\n   vertex.AddProperty(cc.name, component[index[v]]);\n   builder.AddVertex(vertex);\n}\nbuilder.Dump();\n'})})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},395:(e,t,r)=>{r.d(t,{Z:()=>s,a:()=>i});var n=r(959);const a={},o=n.createContext(a);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);
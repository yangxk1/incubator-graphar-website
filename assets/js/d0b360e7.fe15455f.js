"use strict";(self.webpackChunkapache_website_template=self.webpackChunkapache_website_template||[]).push([[1442],{8684:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=n(1527),a=n(395);const s={},i="Integrate into GraphScope",o={id:"libraries/cpp/examples/graphscope",title:"Integrate into GraphScope",description:"GraphScope is a unified distributed graph",source:"@site/docs/libraries/cpp/examples/graphscope.md",sourceDirName:"libraries/cpp/examples",slug:"/libraries/cpp/examples/graphscope",permalink:"/docs/libraries/cpp/examples/graphscope",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/incubator-graphar/edit/main/docs/libraries/cpp/examples/graphscope.md",tags:[],version:"current",frontMatter:{},sidebar:"documentation",previous:{title:"Co-Work with BGL",permalink:"/docs/libraries/cpp/examples/bgl"},next:{title:"Out-of-core Graph Algorithms",permalink:"/docs/libraries/cpp/examples/out-of-core"}},h={},c=[{value:"Performance Report",id:"performance-report",level:2},{value:"Parameter settings",id:"parameter-settings",level:3},{value:"Time performance results",id:"time-performance-results",level:3}];function l(e){const r={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{id:"integrate-into-graphscope",children:"Integrate into GraphScope"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.a,{href:"https://graphscope.io/",children:"GraphScope"})," is a unified distributed graph\ncomputing platform that provides a one-stop environment for performing\ndiverse graph operations on a cluster through a user-friendly Python\ninterface. As an important application case of GraphAr, we have\nintegrated it into GraphScope."]}),"\n",(0,t.jsx)(r.p,{children:"GraphScope works on a graph G fragmented via a partition strategy picked\nby the user and each worker maintains a fragment of G. Given a query, it\nposts the same query to all the workers and computes following the BSP\n(Bulk Synchronous Parallel) model. More specifically, each worker first\nexecutes processing against its local fragment, to compute partial\nanswers in parallel. And then each worker may exchange partial results\nwith other processors via synchronous message passing."}),"\n",(0,t.jsxs)(r.p,{children:["To integrate GraphAr into GraphScope, we implemented\n",(0,t.jsx)(r.em,{children:"ArrowFragmentBuilder"})," and ",(0,t.jsx)(r.em,{children:"ArrowFragmentWriter"}),". ",(0,t.jsx)(r.em,{children:"ArrowFragmentBuilder"}),"\nestablishes the fragments for workers of GraphScope through reading GraphAr\nformat data in parallel. Conversely, ",(0,t.jsx)(r.em,{children:"ArrowFragmentWriter"})," can take the\nGraphScope fragments and save them as GraphAr format files. If you're interested in\nknowing more about the implementation, please refer to the ",(0,t.jsx)(r.a,{href:"https://github.com/v6d-io/v6d/commit/0eda2067e45fbb4ac46892398af0edc84fe1c27b",children:"source\ncode"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"performance-report",children:"Performance Report"}),"\n",(0,t.jsx)(r.h3,{id:"parameter-settings",children:"Parameter settings"}),"\n",(0,t.jsxs)(r.p,{children:["The time performance of ",(0,t.jsx)(r.em,{children:"ArrowFragmentBuilder"})," and ",(0,t.jsx)(r.em,{children:"ArrowFragmentWriter"}),"\nin GraphScope is heavily dependent on the partitioning of the graph into\nGraphAr format files, that is, the ",(0,t.jsx)(r.em,{children:"vertex chunk size"})," and ",(0,t.jsx)(r.em,{children:"edge chunk size"}),", which\nare specified in the vertex information file and in the edge information\nfile, respectively."]}),"\n",(0,t.jsx)(r.p,{children:"Generally speaking, fewer chunks are created if the file size is large.\nOn small graphs, this can be disadvantageous as it reduces the degree of\nparallelism, prolonging disk I/O time. On the other hand, having too\nmany small files increases the overhead associated with the file system\nand the file parser."}),"\n",(0,t.jsxs)(r.p,{children:["We have conducted micro benchmarks to compare the time performance for\nreading/writing GraphAr format files by\n",(0,t.jsx)(r.em,{children:"ArrowFragmentBuilder"}),"/",(0,t.jsx)(r.em,{children:"ArrowFragmentWriter"}),", across different ",(0,t.jsx)(r.em,{children:"vertex\nchunk size"})," and ",(0,t.jsx)(r.em,{children:"edge chunk size"})," configurations. The settings we\nrecommend for ",(0,t.jsx)(r.em,{children:"vertex chunk size"})," and ",(0,t.jsx)(r.em,{children:"edge chunk size"})," are ",(0,t.jsx)(r.strong,{children:"2^18"})," and\n",(0,t.jsx)(r.strong,{children:"2^22"}),", respectively, which lead to efficient performance in most\ncases. These settings can be used as the reference values when\nintegrating GraphAr into other systems besides GraphScope."]}),"\n",(0,t.jsx)(r.h3,{id:"time-performance-results",children:"Time performance results"}),"\n",(0,t.jsxs)(r.p,{children:["Here we report the performance results of ",(0,t.jsx)(r.em,{children:"ArrowFragmentBuilder"}),", and\ncompare it with loading the same graph through the default loading\nstrategy of GraphScope (through reading the csv files in parallel) . The\nexecution time reported below includes loading the graph data from the\ndisk into memory, as well as building GraphScope fragments from such\ndata. The experiments are conducted on a cluster of 4 AliCloud\necs.r6.6xlarge instances (24vCPU, 192GB memory), and using\n",(0,t.jsx)(r.a,{href:"https://snap.stanford.edu/data/com-Friendster.html",children:"com-friendster"})," (a\nsimple graph) and ",(0,t.jsx)(r.a,{href:"https://ldbcouncil.org/benchmarks/snb/",children:"ldbc-snb-30"}),"\n(a multi-labeled property graph) as datasets."]}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Dataset"}),(0,t.jsx)(r.th,{children:"Workers"}),(0,t.jsx)(r.th,{children:"Default Loading"}),(0,t.jsx)(r.th,{children:"GraphAr Loading"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"com-friendster"}),(0,t.jsx)(r.td,{children:"4"}),(0,t.jsx)(r.td,{children:"282s"}),(0,t.jsx)(r.td,{children:"54s"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"ldbc-snb-30"}),(0,t.jsx)(r.td,{children:"4"}),(0,t.jsx)(r.td,{children:"196s"}),(0,t.jsx)(r.td,{children:"40s"})]})]})]})]})}function d(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},395:(e,r,n)=>{n.d(r,{Z:()=>o,a:()=>i});var t=n(959);const a={},s=t.createContext(a);function i(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);
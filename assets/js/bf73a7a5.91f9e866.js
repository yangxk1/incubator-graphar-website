"use strict";(self.webpackChunkapache_website_template=self.webpackChunkapache_website_template||[]).push([[2186],{1187:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var r=n(1527),a=n(395);const i={},s="Out-of-core Graph Algorithms",o={id:"libraries/cpp/examples/out-of-core",title:"Out-of-core Graph Algorithms",description:"An important application case of GraphAr is to serve out-of-core graph",source:"@site/docs/libraries/cpp/examples/out-of-core.md",sourceDirName:"libraries/cpp/examples",slug:"/libraries/cpp/examples/out-of-core",permalink:"/docs/libraries/cpp/examples/out-of-core",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/incubator-graphar/edit/main/docs/libraries/cpp/examples/out-of-core.md",tags:[],version:"current",frontMatter:{},sidebar:"documentation",previous:{title:"Integrate into GraphScope",permalink:"/docs/libraries/cpp/examples/graphscope"},next:{title:"Convert SNAP Datasets to GraphAr Format",permalink:"/docs/libraries/cpp/examples/snap-to-graphar"}},c={},h=[{value:"PageRank",id:"pagerank",level:2},{value:"Connected Components",id:"connected-components",level:2},{value:"Breadth First Search",id:"breadth-first-search",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"out-of-core-graph-algorithms",children:"Out-of-core Graph Algorithms"}),"\n",(0,r.jsx)(t.p,{children:"An important application case of GraphAr is to serve out-of-core graph\nprocessing scenarios. With the graph data saved as GraphAr format files in the\ndisk, GraphAr provides a set of reading interfaces to allow to load part\nof graph data into memory when needed, to conduct analytics. While it is\nmore convenient and efficient to store the entirety of the graph in\nmemory (as is done in BGL), out-of-core graph processing makes it\npossible to complete analytics on the large-scale graphs using limited\nmemory/computing resources."}),"\n",(0,r.jsx)(t.p,{children:"The are some out-of-core graph analytic algorithms that have been\nimplemented based on GraphAr, include:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"PageRank (PR)"}),"\n",(0,r.jsx)(t.li,{children:"Connected Components (CC)"}),"\n",(0,r.jsx)(t.li,{children:"Breadth First Search (BFS)"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"These algorithms represent for different compute patterns and are\nusually building blocks for constructing other graph algorithms."}),"\n",(0,r.jsx)(t.h2,{id:"pagerank",children:"PageRank"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/PageRank",children:"PageRank (PR)"})," is an algorithm\nused by Google Search to rank web pages in their search engine results.\nThe source code of PageRank based on GraphAr located at\n",(0,r.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/pagerank_example.cc",children:"pagerank_example.cc"}),",\nand the explanations can be found in the ",(0,r.jsx)(t.a,{href:"../getting-started#a-pagerank-example",children:"Getting\nStarted"})," page."]}),"\n",(0,r.jsx)(t.h2,{id:"connected-components",children:"Connected Components"}),"\n",(0,r.jsxs)(t.p,{children:["A weakly connected component is a maximal subgraph of a graph such that\nfor every pair of vertices in it, there is an undirected path connecting\nthem. And ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Connected_component",children:"Connected Components\n(CC)"})," is an algorithm\nto identify all weakly connected components in a graph. ",(0,r.jsx)(t.a,{href:"./bgl",children:"CC based on\nBGL"})," is provided in GraphAr, also, we implement out-of-core\nalgorithms for this application."]}),"\n",(0,r.jsx)(t.p,{children:"A typical method for calculating CC is label propagation. In this\nalgorithm, each vertex is attached with a property which represents its\ncomponent label, being its own vertex id initially. In the subsequent\nsupersteps (i.e., iterations), a vertex will update its label if it\nreceives a smaller id and then it propagates this id to all its\nneighbors."}),"\n",(0,r.jsx)(t.p,{children:"This algorithm can be implemented based on streaming the edges via\nGraphAr's reading interface. That is to say, the edges are accessed and\nprocessed chunk by chunk, instead of being loaded into memory at once\n(as in the BGL example)."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c++",children:"// construct the edge collection in GraphAr\nauto edges = ...\nauto it_begin = edges->begin(), it_end = edges->end();\n\n// initialize for all vertices\nstd::vector<graphar::IdType> component(num_vertices);\nfor (graphar::IdType i = 0; i < num_vertices; i++)\n  component[i] = i;\n\n// stream all edges for each iteration\nfor (int iter = 0; ; iter++) {\n  bool flag = false;\n  for (auto it = it_begin; it != it_end; ++it) {\n    graphar::IdType src = it.source(), dst = it.destination();\n    // update\n    if (component[src] < component[dst]) {\n        component[dst] = component[src];\n        flag = true;\n    } else if (component[src] > component[dst]) {\n        component[src] = component[dst];\n        flag = true;\n    }\n  }\n  // check if it should terminate\n  if (!flag) break;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The file\n",(0,r.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/cc_stream_example.cc",children:"cc_stream_example.cc"}),"\nlocated inside the source tree contains the complete implementation for\nthis algorithm. Also, we can only process active vertices (the vertices\nwhich are updated in the last iteration) and the corresponding edges for\neach iteration, since an inactive vertex does not need to update its\nneighbors. Please refer to\n",(0,r.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/cc_push_example.cc",children:"cc_push_example.cc"}),"\nfor the complete code."]}),"\n",(0,r.jsxs)(t.admonition,{type:"tip",children:[(0,r.jsxs)(t.p,{children:["In this example, two kinds of edges are used. The\n",(0,r.jsx)(t.strong,{children:"ordered_by_source"})," edges are used to access all outgoing edges of\nan active vertex, and ",(0,r.jsx)(t.strong,{children:"ordered_by_dest"})," edges are used to access the\nincoming edges. In this way, all the neighbors of an active vertex can\nbe accessed and processed."]}),(0,r.jsxs)(t.p,{children:["Although GraphAr supports to get the outgoing (incoming) edges of a\nsingle vertex for all adjList types, it is most efficient when the\ntype is ",(0,r.jsx)(t.strong,{children:"ordered_by_source"})," (",(0,r.jsx)(t.strong,{children:"ordered_by_dest"}),") since it can avoid\nto read redundant data."]})]}),"\n",(0,r.jsx)(t.h2,{id:"breadth-first-search",children:"Breadth First Search"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Breadth-first_search",children:"Breadth First Search\n(BFS)"})," is a\ntraversing algorithm that starts from a selected vertex (the root) and\ntraverse the graph layer-wise thus exploring the neighbor vertices\n(vertices which are directly connected to the root), and then it moves\ntowards the next-level neighbor vertices."]}),"\n",(0,r.jsxs)(t.p,{children:["An out-of-core BFS algorithm could be implemented based on streaming the\ngraph data via GraphAr. For each vertex, a property named ",(0,r.jsx)(t.em,{children:"distance"})," is\ncreated and initialized to represent the distance from the root to this\nvertex. As with the standard BFS algorithms in other graph processing\nsystems, for the iteration/superstep ",(0,r.jsx)(t.em,{children:"i"})," (starting from 0), the active\nvertices contain all vertices reachable from the root in ",(0,r.jsx)(t.em,{children:"i"})," hops (i.e.,\n",(0,r.jsx)(t.em,{children:"distance[v]= i"}),"). At the beginning of the algorithm, only the root\nvertex is active. This algorithm terminates when there are no more\nactive vertices."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c++",children:"// construct the edge collection in GraphAr\nauto edges = ...\nauto it_begin = edges->begin(), it_end = edges->end();\n\n// initialize for all vertices\ngraphar::IdType root = 0; // the BFS root\nstd::vector<int32_t> distance(num_vertices);\nfor (graphar::IdType i = 0; i < num_vertices; i++)\n  distance[i] = (i == root ? 0 : -1);\n\n// stream all edges for each iteration\nfor (int iter = 0; ; iter++) {\n  graphar::IdType count = 0;\n  for (auto it = it_begin; it != it_end; ++it) {\n    graphar::IdType src = it.source(), dst = it.destination();\n    // update\n    if (distance[src] == iter && distance[dst] == -1) {\n      distance[dst] = distance[src] + 1;\n      count++;\n    }\n  }\n  // check if it should terminate\n  if (count == 0) break;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The above algorithm is implemented based on streaming all edges for each\niteration, the source code can be found at\n",(0,r.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/bfs_stream_example.cc",children:"bfs_stream_example.cc"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Meanwhile, BFS could be implemented in a ",(0,r.jsx)(t.strong,{children:"push"}),"-style which only\ntraverses the edges that from active vertices for each iteration, which\nis typically more efficient on real-world graphs. This implementation\ncan be found at\n",(0,r.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/bfs_push_example.cc",children:"bfs_push_example.cc"}),".\nSimilarly, we provide a BFS implementation in a ",(0,r.jsx)(t.strong,{children:"pull"}),"-style which\nonly traverses the edges that lead to non-visited vertices (i.e., the\nvertices that have not been traversed), as shown in\n",(0,r.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/bfs_pull_example.cc",children:"bfs_pull_example.cc"}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["In common cases of graph processing, the ",(0,r.jsx)(t.strong,{children:"push"}),"-style is more\nefficient when the set of active vertices is very sparse, while the\n",(0,r.jsx)(t.strong,{children:"pull"}),"-style fits when it is dense."]})}),"\n",(0,r.jsxs)(t.p,{children:["In some cases, it is required to record the path of BFS, that is, to\nmaintain each vertex's predecessor (also called ",(0,r.jsx)(t.em,{children:"father"}),") in the\ntraversing tree rather than only recording the distance. The\nimplementation of BFS with recording fathers can be found at\n",(0,r.jsx)(t.a,{href:"https://github.com/apache/incubator-graphar/blob/main/cpp/examples/bfs_father_example.cc",children:"bfs_father_example.cc"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},395:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var r=n(959);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);